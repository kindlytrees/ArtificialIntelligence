# 实验手册

## ceres优化库的使用

具体实例见文件`ceresCurveFitting.cpp`

下面的这段代码参考cartographer中的实现，具体文件路径见：
.\cartographer\cartographer\mapping\internal\2d\scan_matching\ceres_scan_matcher_2d.cc

```
  double ceres_pose_estimate[3] = {initial_pose_estimate.translation().x(),
                                   initial_pose_estimate.translation().y(),
                                   initial_pose_estimate.rotation().angle()};
  ceres::Problem problem;
  CHECK_GT(options_.occupied_space_weight(), 0.);
  switch (grid.GetGridType()) {
    case GridType::PROBABILITY_GRID:
      problem.AddResidualBlock(
          CreateOccupiedSpaceCostFunction2D(
              options_.occupied_space_weight() /
                  std::sqrt(static_cast<double>(point_cloud.size())),
              point_cloud, grid),
          nullptr //loss function
          ,ceres_pose_estimate);
      break;
    case GridType::TSDF:
      problem.AddResidualBlock(
          CreateTSDFMatchCostFunction2D(
              options_.occupied_space_weight() /
                  std::sqrt(static_cast<double>(point_cloud.size())),
              point_cloud, static_cast<const TSDF2D&>(grid)),
          nullptr,  //loss function
          ceres_pose_estimate);
      break;
  }
```

## g2o优化库的使用

与领域问题结构高度匹配、且能进行深度性能优化的框架，g2o图优化方法，基于节点和边的定义，具体采用的优化方法可以是GN, LM, DogLeg等

顶点类用于封装待优化的变量，g2o求解器计算出的更新量是一个小的增量 delta，oplusImpl 定义了如何将这个增量应用到当前估计值上
边类用于封装一个误差项，以及如何计算这个误差和它对顶点的导数（雅可比矩阵）

Ceres的自动求导极大地降低了使用门槛，避免了复杂的手动求导和编码错误。g2o需要用户具备微积分知识并手动实现，但这也给了用户极致的性能控制
具体的基于g2o的位姿图优化算法请参考后续章节实验